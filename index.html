<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Energy Ring - Curl Noise</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #gui-container { position: absolute; top: 10px; right: 10px; z-index: 100; }
    </style>
    <!-- Import Maps for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="gui-container"></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'three/addons/libs/lil-gui.module.min.js';

        // --- Configuration ---
        const CONFIG = {
            // Geometry Settings
            particles: 12000,
            ringRadius: 5.0,
            dispersalInner: 0.2,    
            dispersalOuter: 1.5,
            directionSpread: 0.1,   
            
            // Visuals
            color1: '#00d2ff',
            color2: '#3a7bd5',
            shardSize: 0.5394,         
            shardLength: 0.5282,       
            shardThickness: 0.03,   
            
            // Animation / Physics
            outwardSpeed: 0.5,
            outwardDistance: 2.0,   
            lifeFadeIn: 0.1,        
            lifeFadeOut: 0.6,       
            noiseStrength: 0.352,     // Turbulence
            rotationSpeed: 0.2,
            shadowSpeed: 0.0,
            
            // Shadows (Dim Spots)
            shadowRadius: 0.0,
            shadowDarkness: 0.0,
            
            // Fragmentation Settings
            fragmentScale: 1.0,
            fragmentSpeed: 0.2,
            fragmentAmount: 0.5,
            
            // Bloom
            bloomStrength: 1.8,
            bloomRadius: 0.5,
            bloomThreshold: 0.05
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 16);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 1. The Physical Ring Body (Core) ---
        const coreGeometry = new THREE.TorusGeometry(CONFIG.ringRadius, 0.05, 16, 100);
        const coreMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000,
            emissive: new THREE.Color(CONFIG.color1),
            emissiveIntensity: 2,
            roughness: 0.1,
            metalness: 1.0
        });
        const coreRing = new THREE.Mesh(coreGeometry, coreMaterial);
        scene.add(coreRing);

        // --- SHARED SHADER LOGIC (Instanced Mesh) ---
        
        const commonVertexShader = `
            uniform float uTime;
            uniform float uSize;            
            uniform float uNoiseStrength;
            uniform float uOutwardSpeed;
            uniform float uOutwardDistance;
            uniform float uFragmentScale;
            uniform float uFragmentSpeed;
            
            // Instanced Attributes
            attribute vec3 aInstancePosition;
            attribute float aScale;
            attribute vec3 aRandomness;
            attribute vec3 aDirection;
            attribute float aLifeOffset;
            
            varying vec3 vPos;
            varying float vAlphaScale;
            varying float vLife;
            varying float vFragNoise;
            varying vec2 vUv;

            // --- Simplex Noise 3D (Standard Implementation) ---
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                
                // First corner
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                
                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );

                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
                
                // Permutations
                i = mod289(i);
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                          
                // Gradients: 7x7 points over a square, mapped onto an octahedron.
                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
                float n_ = 0.142857142857; // 1.0/7.0
                vec3  ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );

                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);

                //Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                // Mix final noise value
                vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                              dot(p2,x2), dot(p3,x3) ) );
            }

            // Helper to get 3 noise values for Curl Calc
            vec3 snoiseVec3( vec3 x ){
                float s  = snoise(vec3( x ));
                float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));
                float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));
                return vec3( s , s1 , s2 );
            }

            // --- Curl Noise Function ---
            // Calculates the curl of a simplex noise potential field
            vec3 curlNoise( vec3 p ){
                const float e = 0.1;
                vec3 dx = vec3( e   , 0.0 , 0.0 );
                vec3 dy = vec3( 0.0 , e   , 0.0 );
                vec3 dz = vec3( 0.0 , 0.0 , e   );

                vec3 p_x0 = snoiseVec3( p - dx );
                vec3 p_x1 = snoiseVec3( p + dx );
                vec3 p_y0 = snoiseVec3( p - dy );
                vec3 p_y1 = snoiseVec3( p + dy );
                vec3 p_z0 = snoiseVec3( p - dz );
                vec3 p_z1 = snoiseVec3( p + dz );

                float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
                float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
                float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

                const float divisor = 1.0 / ( 2.0 * e );
                return normalize( vec3( x , y , z ) * divisor );
            }

            float simpleNoise(vec3 p) {
                return snoise(p * uFragmentSpeed + uTime * 0.5);
            }

            // Rotation Matrix Builder: Aligns UP (Y) to Target Direction
            mat3 alignVector(vec3 dir) {
                vec3 up = vec3(0.0, 1.0, 0.0);
                vec3 axis = cross(up, dir);
                float angle = acos(dot(up, dir));
                
                if (length(axis) < 0.001) return mat3(1.0);
                
                axis = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float oc = 1.0 - c;
                
                return mat3(
                    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
                );
            }

            void main() {
                vUv = uv;

                // 1. Calculate Lifecycle
                float life = mod(uTime * uOutwardSpeed + aLifeOffset, 1.0);
                vLife = life;

                // 2. Calculate Center Position of the Instance
                vec3 instanceCenter = aInstancePosition;
                
                // Move outward based on life
                instanceCenter += aDirection * (life * uOutwardDistance);
                
                // --- APPLY CURL NOISE ---
                // We sample the curl field at the particle position (moving with time)
                vec3 curl = curlNoise( instanceCenter * 0.5 - vec3(0.0, 0.0, uTime * 0.2) );
                
                // Displace position based on curl
                instanceCenter += curl * uNoiseStrength;

                // Breathing
                float breath = 1.0 + sin(uTime * 1.0) * 0.02;
                instanceCenter *= breath;

                vPos = instanceCenter; 
                vFragNoise = simpleNoise(instanceCenter * uFragmentScale);

                // 3. Orient and Scale the Mesh (Cone)
                // We mix the original direction with the curl vector for orientation
                // This makes the shards align with the "flow" of the smoke
                vec3 orientDir = normalize(aDirection + curl * 0.5);
                mat3 rotMatrix = alignVector(orientDir); 
                
                vec3 transformed = position;
                
                // Scale the geometry itself
                transformed *= uSize * aScale; 
                
                // Apply Twinkle scale
                float twinkle = 0.8 + 0.4 * sin(uTime * 3.0 + aRandomness.x * 10.0);
                transformed *= twinkle;
                vAlphaScale = twinkle;

                // Rotate geometry to point outward
                transformed = rotMatrix * transformed;

                // Move to instance position
                vec3 finalPos = instanceCenter + transformed;

                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // --- Fragment Shader ---
        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uShadowPos1;
            uniform vec3 uShadowPos2;
            uniform float uShadowRadius;
            uniform float uShadowDarkness;
            uniform float uFragmentAmount;
            uniform float uLifeFadeIn;
            uniform float uLifeFadeOut;
            
            varying vec3 vPos;
            varying float vAlphaScale;
            varying float vLife;
            varying float vFragNoise;
            varying vec2 vUv;

            void main() {
                float alpha = 1.0;

                // Lifecycle Fade
                float lifeFade = smoothstep(0.0, uLifeFadeIn, vLife) * (1.0 - smoothstep(uLifeFadeOut, 1.0, vLife));
                alpha *= lifeFade;

                // Fragmentation
                float noiseVal = vFragNoise * 0.5 + 0.5;
                float structuralIntegrity = mix(1.0, noiseVal, uFragmentAmount);
                alpha *= structuralIntegrity;

                // Color Gradient
                vec3 finalColor = mix(uColor1, uColor2, (vPos.y + 5.0) / 10.0);

                // Rim Light / Core Brightness
                float core = 1.0 - abs(vUv.x - 0.5) * 2.0;
                finalColor += vec3(0.5) * core; 

                // Shadows
                float distToShadow1 = distance(vPos, uShadowPos1);
                float shadowFactor1 = smoothstep(0.0, uShadowRadius, distToShadow1);
                
                float distToShadow2 = distance(vPos, uShadowPos2);
                float shadowFactor2 = smoothstep(0.0, uShadowRadius, distToShadow2);

                float totalShadow = shadowFactor1 * shadowFactor2;
                alpha *= totalShadow;
                
                vec3 dimColor = finalColor * uShadowDarkness;
                finalColor = mix(dimColor, finalColor, totalShadow);

                gl_FragColor = vec4(finalColor, alpha * vAlphaScale);
            }
        `;

        // --- Setup Systems ---
        
        let brightMesh; 
        let particlesGeometry;

        // Bright Material
        const particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uSize: { value: CONFIG.shardSize },
                uColor1: { value: new THREE.Color(CONFIG.color1) },
                uColor2: { value: new THREE.Color(CONFIG.color2) },
                uNoiseStrength: { value: CONFIG.noiseStrength },
                uOutwardSpeed: { value: CONFIG.outwardSpeed },
                uOutwardDistance: { value: CONFIG.outwardDistance },
                uLifeFadeIn: { value: CONFIG.lifeFadeIn },
                uLifeFadeOut: { value: CONFIG.lifeFadeOut },
                uShadowPos1: { value: new THREE.Vector3(10, 0, 0) },
                uShadowPos2: { value: new THREE.Vector3(-10, 0, 0) },
                uShadowRadius: { value: CONFIG.shadowRadius },
                uShadowDarkness: { value: CONFIG.shadowDarkness },
                uFragmentScale: { value: CONFIG.fragmentScale },
                uFragmentSpeed: { value: CONFIG.fragmentSpeed },
                uFragmentAmount: { value: CONFIG.fragmentAmount }
            },
            vertexShader: commonVertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });


        // --- Generator Function (Instanced Geometry) ---
        function generateParticles() {
            // Cleanup Old
            if (brightMesh) { scene.remove(brightMesh); brightMesh.geometry.dispose(); }

            // 1. Create Base Geometry for the "Shard"
            const baseGeo = new THREE.ConeGeometry(CONFIG.shardThickness, CONFIG.shardLength, 3);
            baseGeo.translate(0, CONFIG.shardLength / 2, 0);

            // 2. Helper to build attributes
            function buildAttributes(count) {
                const positions = new Float32Array(count * 3);
                const scales = new Float32Array(count);
                const randomness = new Float32Array(count * 3);
                const directions = new Float32Array(count * 3);
                const lifeOffsets = new Float32Array(count);
                
                const ringR = CONFIG.ringRadius;

                for (let i = 0; i < count; i++) {
                    const u = Math.random() * Math.PI * 2; 
                    const v = Math.random() * Math.PI * 2; 
                    
                    // DECOUPLED DISPERSAL LOGIC
                    const t = (Math.cos(v) + 1) / 2; 
                    const maxR = CONFIG.dispersalInner + t * (CONFIG.dispersalOuter - CONFIG.dispersalInner);
                    const r = Math.random() * maxR;
                    
                    const centerX = ringR * Math.cos(u);
                    const centerY = ringR * Math.sin(u);
                    const centerZ = 0;

                    const x = (ringR + r * Math.cos(v)) * Math.cos(u);
                    const y = (ringR + r * Math.cos(v)) * Math.sin(u);
                    const z = r * Math.sin(v);

                    // Direction Calculation with Spread
                    const dir = new THREE.Vector3(x - centerX, y - centerY, z - centerZ);
                    
                    // Apply Spread (Noise) to Direction
                    dir.x += (Math.random() - 0.5) * CONFIG.directionSpread;
                    dir.y += (Math.random() - 0.5) * CONFIG.directionSpread;
                    dir.z += (Math.random() - 0.5) * CONFIG.directionSpread;
                    
                    dir.normalize();

                    positions[i*3] = x;
                    positions[i*3+1] = y;
                    positions[i*3+2] = z;

                    scales[i] = 0.5 + Math.random() * 0.5;
                    
                    randomness[i*3] = Math.random();
                    randomness[i*3+1] = Math.random();
                    randomness[i*3+2] = Math.random();

                    directions[i*3] = dir.x;
                    directions[i*3+1] = dir.y;
                    directions[i*3+2] = dir.z;

                    lifeOffsets[i] = Math.random();
                }
                return { positions, scales, randomness, directions, lifeOffsets };
            }

            // 3. Create Instanced Meshes
            const brightData = buildAttributes(CONFIG.particles);
            particlesGeometry = new THREE.InstancedBufferGeometry();
            particlesGeometry.index = baseGeo.index;
            particlesGeometry.attributes.position = baseGeo.attributes.position;
            particlesGeometry.attributes.uv = baseGeo.attributes.uv;
            
            particlesGeometry.setAttribute('aInstancePosition', new THREE.InstancedBufferAttribute(brightData.positions, 3));
            particlesGeometry.setAttribute('aScale', new THREE.InstancedBufferAttribute(brightData.scales, 1));
            particlesGeometry.setAttribute('aRandomness', new THREE.InstancedBufferAttribute(brightData.randomness, 3));
            particlesGeometry.setAttribute('aDirection', new THREE.InstancedBufferAttribute(brightData.directions, 3));
            particlesGeometry.setAttribute('aLifeOffset', new THREE.InstancedBufferAttribute(brightData.lifeOffsets, 1));
            
            brightMesh = new THREE.Mesh(particlesGeometry, particlesMaterial);
            brightMesh.frustumCulled = false; 
            scene.add(brightMesh);

            // Update Core
            if(coreRing.geometry) coreRing.geometry.dispose();
            coreRing.geometry = new THREE.TorusGeometry(CONFIG.ringRadius, 0.05, 16, 100);
        }

        generateParticles();


        // --- Post-Processing ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            CONFIG.bloomStrength,
            CONFIG.bloomRadius,
            CONFIG.bloomThreshold
        );

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        const shadowPivot = { angle: 0 };

        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();
            
            // Update Uniforms
            particlesMaterial.uniforms.uTime.value = elapsedTime;

            const rotSpeed = CONFIG.rotationSpeed * 0.01;
            brightMesh.rotation.z -= rotSpeed;
            coreRing.rotation.z -= rotSpeed;
            
            // --- Shadow Logic ---
            shadowPivot.angle += CONFIG.shadowSpeed * 0.02;
            
            const sX1 = Math.cos(shadowPivot.angle) * CONFIG.ringRadius;
            const sY1 = Math.sin(shadowPivot.angle) * CONFIG.ringRadius;
            particlesMaterial.uniforms.uShadowPos1.value.set(sX1, sY1, 0);

            const sX2 = Math.cos(shadowPivot.angle + Math.PI) * CONFIG.ringRadius;
            const sY2 = Math.sin(shadowPivot.angle + Math.PI) * CONFIG.ringRadius;
            particlesMaterial.uniforms.uShadowPos2.value.set(sX2, sY2, 0);

            controls.update();
            composer.render();
        }

        // --- GUI Setup ---
        const gui = new GUI({ title: 'Energy Ring Controls' });
        
        const folderGeo = gui.addFolder('Geometry & Counts');
        folderGeo.add(CONFIG, 'ringRadius', 1, 10).name('Ring Radius').onChange(generateParticles);
        
        // --- REQUESTED CONTROLS ---
        folderGeo.add(CONFIG, 'dispersalInner', 0, 2).name('Dispersal Inner').onChange(generateParticles);
        folderGeo.add(CONFIG, 'dispersalOuter', 0, 5).name('Dispersal Outer').onChange(generateParticles);
        folderGeo.add(CONFIG, 'directionSpread', 0, 1.0).name('Direction Spread').onChange(generateParticles);
        
        // --- RENAMED CONTROL ---
        folderGeo.add(CONFIG, 'particles', 1000, 20000).step(1000).name('Particle Count').onFinishChange(generateParticles);

        const folderShard = gui.addFolder('Shard Shape (MeshLine)');
        folderShard.add(CONFIG, 'shardSize', 0.1, 3.0).name('Global Scale').onChange(v => {
            particlesMaterial.uniforms.uSize.value = v;
        });
        folderShard.add(CONFIG, 'shardLength', 0.1, 2.0).name('Shard Length').onFinishChange(generateParticles);
        folderShard.add(CONFIG, 'shardThickness', 0.01, 0.2).name('Shard Thickness').onFinishChange(generateParticles);

        const folderShadows = gui.addFolder('Shadows');
        folderShadows.add(CONFIG, 'shadowRadius', 0, 10).name('Shadow Radius').onChange(v => particlesMaterial.uniforms.uShadowRadius.value = v);
        folderShadows.add(CONFIG, 'shadowDarkness', 0, 1.0).name('Shadow Strength').onChange(v => particlesMaterial.uniforms.uShadowDarkness.value = v);
        folderShadows.add(CONFIG, 'shadowSpeed', 0, 5).name('Orbit Speed');

        const folderVisuals = gui.addFolder('Colors & Light');
        folderVisuals.addColor(CONFIG, 'color1').name('Inner Color').onChange(v => {
            particlesMaterial.uniforms.uColor1.value.set(v);
            coreMaterial.emissive.set(v);
        });
        folderVisuals.addColor(CONFIG, 'color2').name('Outer Color').onChange(v => particlesMaterial.uniforms.uColor2.value.set(v));
        folderVisuals.add(CONFIG, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);

        const folderPhys = gui.addFolder('Physics & Noise');
        folderPhys.add(CONFIG, 'fragmentAmount', 0, 1).name('Noise Break').onChange(v => particlesMaterial.uniforms.uFragmentAmount.value = v);
        folderPhys.add(CONFIG, 'fragmentScale', 0.1, 5.0).name('Noise Scale').onChange(v => {
             particlesMaterial.uniforms.uFragmentScale.value = v; 
        });
        folderPhys.add(CONFIG, 'outwardSpeed', 0, 2.0).name('Dispersal Spd').onChange(v => {
            particlesMaterial.uniforms.uOutwardSpeed.value = v; 
        });
        folderPhys.add(CONFIG, 'outwardDistance', 0, 5.0).name('Dispersal Dist').onChange(v => {
            particlesMaterial.uniforms.uOutwardDistance.value = v; 
        });
        folderPhys.add(CONFIG, 'lifeFadeIn', 0.01, 0.5).name('Fade In (Inner)').onChange(v => {
            particlesMaterial.uniforms.uLifeFadeIn.value = v;
        });
        folderPhys.add(CONFIG, 'lifeFadeOut', 0.1, 1.0).name('Fade Out (Outer)').onChange(v => {
            particlesMaterial.uniforms.uLifeFadeOut.value = v;
        });
        folderPhys.add(CONFIG, 'noiseStrength', 0, 2.0).name('Turbulence').onChange(v => {
            particlesMaterial.uniforms.uNoiseStrength.value = v;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>